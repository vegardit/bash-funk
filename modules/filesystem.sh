#!/usr/bin/env bash
#
# Copyright (c) 2015-2017 Vegard IT GmbH, http://vegardit.com
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# @author Sebastian Thomschke, Vegard IT GmbH
# @author Patrick Spielmann, Vegard IT GmbH

#
# THIS FILE IS GENERATED BY BASH-FUNK GENERATOR
#
function -abspath() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-abspath() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _PATH
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.')"
                echo "      The path to normalize."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    ######### abspath ######### START


# use realpath if available
if hash realpath &>/dev/null; then
    realpath -m $_PATH

# use python as last resort
else
    python -c "import os
print os.path.abspath('$_PATH')"
fi

    ######### abspath ######### END
}
function __complete-abspath() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}abspath -- ${BASH_FUNK_PREFIX:--}abspath

function -cd-down() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... DIR_NAME"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-cd-down() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _DIR_NAME
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... DIR_NAME"
                echo
                echo "Jumps down in the tree of the current directory to the first sub directory found with the given name."
                echo
                echo "Parameters:"
                echo -e "  \033[1mDIR_NAME\033[22m (required)"
                echo "      The name of the subdirectory to locate and cd into."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_DIR_NAME ]]; then
            _DIR_NAME=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_DIR_NAME ]]; then
        true
    else
        echo "$__fn: Error: Parameter DIR_NAME must be specified."; return 64
    fi

    ######### cd-down ######### START

local path=$(find . -name "$_DIR_NAME" -type d -print -quit 2>/dev/null || true);
if [[ $path ]]; then
    echo "$path"
    cd $path
else
    echo "$__fn: $_DIR_NAME: No such directory"
    return 1
fi

    ######### cd-down ######### END
}
function __complete-cd-down() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cd-down -- ${BASH_FUNK_PREFIX:--}cd-down

function -cd-hist() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [STEPS_OR_DIRNAME]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-cd-hist() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _STEPS_OR_DIRNAME
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [STEPS_OR_DIRNAME]"
                echo
                echo "Navigates back in the directory history which can be managed via pushd/popd/dirs and is automatically populated if the Bash Funk bash-prompt is installed."
                echo
                echo "Parameters:"
                echo -e "  \033[1mSTEPS_OR_DIRNAME\033[22m "
                echo "      The name of the subdirectory to locate and cd into. If not specified a list of the last 20 entries is displayed."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_STEPS_OR_DIRNAME && ${#__params[@]} > 0 ]]; then
            _STEPS_OR_DIRNAME=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### cd-hist ######### START

if [[ ! $_STEPS_OR_DIRNAME ]]; then
    echo "Directory history:"
    for (( __idx=2; __idx<${#DIRSTACK[*]}; __idx++ )); do
        echo "$(( __idx - 1 )) cd ${DIRSTACK[$__idx]}"
        [[ $__idx -eq 22 ]] && break || true
    done
    return 0
fi

if [[ $_STEPS_OR_DIRNAME == "-" ]]; then
    cd - && return 0 || return 1
fi

if [[ $_STEPS_OR_DIRNAME =~ ^[0-9]+$ ]]; then
    local path="${DIRSTACK[@]:$(( _STEPS_OR_DIRNAME + 1 )):1}"
    echo "$path"
    cd $path
else
    local path
    for path in "${DIRSTACK[@]}"; do
        case "${path}" in
            *"/"$_STEPS_OR_DIRNAME)
                echo "$path"
                cd "$path"
                return 0;
          ;;
        esac
    done
    echo "$__fn: $_STEPS_OR_DIRNAME: No such directory in history"
    return 1
fi

    ######### cd-hist ######### END
}
function __complete-cd-hist() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cd-hist -- ${BASH_FUNK_PREFIX:--}cd-hist

function -cd-up() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [LEVEL_OR_PATTERN]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-cd-up() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _LEVEL_OR_PATTERN
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [LEVEL_OR_PATTERN]"
                echo
                echo "Navigates up in the current directory tree to the first parent directory found with the given namen or the given number of levels. Bash completion will auto-complete the names of the parent directories."
                echo
                echo "Parameters:"
                echo -e "  \033[1mLEVEL_OR_PATTERN\033[22m (default: '..')"
                echo "      The number of directories to navigate up in the directory tree or the glob pattern to find a matching directory."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_LEVEL_OR_PATTERN && ${#__params[@]} > 0 ]]; then
            _LEVEL_OR_PATTERN=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_LEVEL_OR_PATTERN ]]; then _LEVEL_OR_PATTERN=".."; fi

    ######### cd-up ######### START

if [[ $_LEVEL_OR_PATTERN == ".." ]]; then
    cd ..
    return 0
fi

# check if value is numeric
if [[ $_LEVEL_OR_PATTERN =~ ^[0-9]+$ ]]; then
    local path
    for (( i = 0; i < _LEVEL_OR_PATTERN; i++ )); do
        path="../$path"
    done
    echo "$path"
    cd "$path"

else
    local elem path=()

    # read current path elements into array 'path'
    IFS=/ read -r -a path <<< "$PWD"

    # iterate reverse through the array and check for matching directory
    for (( idx=${#path[@]}-2; idx>=0; idx-- )); do
        case "${path[idx]}" in
            $_LEVEL_OR_PATTERN)
                # join the path
                IFS="/" eval 'path="${path[*]:0:$((idx+1))}"'
                echo "$path"
                cd "$path"
                return 0;
          ;;
        esac
    done
    echo "$__fn: $_LEVEL_OR_PATTERN: No such directory"
    return 1
fi

    ######### cd-up ######### END
}
function __complete-cd-up() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        local path="$PWD"; COMPREPLY=($(IFS=$'\n' compgen -o default -W "$( echo -e "${path////\n}" | sed 's/^/\x27/; s/$/\x27/' )" -- "$curr"))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}cd-up -- ${BASH_FUNK_PREFIX:--}cd-up

function -count-words() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE WORD1[WORD]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-count-words() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _sort _help _selftest _FILE _WORD=()
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... FILE WORD1[WORD]..."
                echo
                echo "Counts the number of occurences of the word(s) in the given file."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE\033[22m (required)"
                echo "      The file to analyze."
                echo -e "  \033[1mWORD\033[22m (1 or more required)"
                echo "      The word to count."
                echo
                echo "Options:"
                echo -e "\033[1m-s, --sort MODE\033[22m (one of: [count,word])"
                echo "        Specifies how to sort the output."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --sort|-s)
                _sort="@@##@@"
                __optionWithValue=sort
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    sort)
                        _sort=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE ]]; then
            _FILE=$__param
            continue
        fi
        _WORD+=("$__param")
        continue
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_sort ]]; then
        if [[ $_sort == "@@##@@" ]]; then echo "$__fn: Error: Value MODE for option --sort must be specified."; return 64; fi
        declare -A __allowed=( [count]=1 [word]=1 )
        if [[ ! ${__allowed[$_sort]} ]]; then echo "$__fn: Error: Value '$_sort' for option --sort is not one of the allowed values [count,word]."; return 64; fi
    fi

    if [[ $_FILE ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILE must be specified."; return 64
    fi
    if [[ ${#_WORD[@]} -lt 1 ]]; then echo "$__fn: Error: For parameter WORD 1 value(s) must be specified. Found: ${#_WORD[@]}."; return 64; fi

    ######### count-words ######### START

if [[ ! -e "$_FILE" ]]; then
    echo "Error: File [$_FILE] does not exist."
    return 1
fi

if [[ ! -r "$_FILE" ]]; then
    echo "Error: File [$_FILE] is not readable by user '$USER'."
    return 1
fi

if [[ ! -f "$_FILE" ]]; then
    echo "Error: Path [$_FILE] does not point to a file."
    return 1
fi

local sedCmds grepCmds
for word in "${_WORD[@]}"; do
    sedCmds="s/$word/\n$word\n/g; $sedCmds"
    grepCmds="$grepCmds -e $word"
done

if [[ $_sort == "count" ]]; then
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c | sort -r
else
    sed "$sedCmds" "$_FILE" | grep $grepCmds | sort | uniq -c
fi

    ######### count-words ######### END
}
function __complete-count-words() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --sort -s --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        local prev="${COMP_WORDS[COMP_CWORD-1]}"
        case $prev in
            --sort|-s)
                COMPREPLY=($(compgen -o default -W "count
word" -- $curr))
              ;;
            *)
                COMPREPLY=($(compgen -o default -- $curr))
              ;;
        esac
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}count-words -- ${BASH_FUNK_PREFIX:--}count-words

function -du() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-du() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _PATH=()
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]..."
                echo
                echo "Prints disk usage information."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The path to check."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        local __leftoverParams=$(( ${#__params[@]} - 0 - ${#_PATH[@]} ))
        if [[ $__leftoverParams -gt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### du ######### START

[[ ! $_PATH ]] && _PATH=(.) || true

du -s -h "${_PATH[@]}"

    ######### du ######### END
}
function __complete-du() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}du -- ${BASH_FUNK_PREFIX:--}du

function -extract() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... ARCHIVE [TO_DIR]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-extract() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _ARCHIVE _TO_DIR
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... ARCHIVE [TO_DIR]"
                echo
                echo "Extracts the given archive using the compatible extractor."
                echo
                echo "Parameters:"
                echo -e "  \033[1mARCHIVE\033[22m (required, file)"
                echo "      The archive to extract."
                echo -e "  \033[1mTO_DIR\033[22m "
                echo "      The target folder."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_ARCHIVE ]]; then
            _ARCHIVE=$__param
            continue
        fi
        if [[ ! $_TO_DIR ]]; then
            _TO_DIR=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_ARCHIVE ]]; then
        if [[ ! -e "$_ARCHIVE" ]]; then echo "$__fn: Error: File '$_ARCHIVE' for parameter ARCHIVE does not exist."; return 64; fi
        if [[ -e "$_ARCHIVE" && ! -f "$_ARCHIVE" ]]; then echo "$__fn: Error: Path '$_ARCHIVE' for parameter ARCHIVE is not a file."; return 64; fi
        if [[ ! -r "$_ARCHIVE" ]]; then echo "$__fn: Error: File '$_ARCHIVE' for parameter ARCHIVE is not readable by user '$USER'."; return 64; fi
    else
        echo "$__fn: Error: Parameter ARCHIVE must be specified."; return 64
    fi

    ######### extract ######### START

if [[ $_TO_DIR ]]; then
    local origPWD="$PWD"
    mkdir "$_TO_DIR"
    cd "$_TO_DIR"
fi

if [[ ! -w "$PWD" ]]; then
    echo "Error: Path [$PWD] is not writeable."
    return 1
fi

local tmpDir=$(mktemp -d -p "$PWD")

case "$_FILE" in
    *.bz2)            bunzip2    "$_ARCHIVE" ;;
    *.gz)             gunzip     "$_ARCHIVE" ;;
    *.rar)            unrar x    "$_ARCHIVE" ;;
    *.tar)            tar xvf    "$_ARCHIVE" ;;
    *.tbz2|*.tar.bz2) tar xvjf   "$_ARCHIVE" ;;
    *.tgz|*.tar.gz)   tar xvzf   "$_ARCHIVE" ;;
    *.zip)            unzip      "$_ARCHIVE" ;;
    *.Z)              uncompress "$_ARCHIVE" ;;
    *.7z)             7z x       "$_ARCHIVE" ;;
    *) echo "Error: Unsupported archive format '$_ARCHIVE'"; return 1 ;;
esac

if [[ $_TO_DIR ]]; then
    cd "$origPWD"
fi

    ######### extract ######### END
}
function __complete-extract() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}extract -- ${BASH_FUNK_PREFIX:--}extract

function -find-up() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILENAME"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-find-up() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _type _help _selftest _FILENAME
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... FILENAME"
                echo
                echo "Traverses the directory upward to find the given file."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILENAME\033[22m (required)"
                echo "      The file or directory to find."
                echo
                echo "Options:"
                echo -e "\033[1m-t, --type TYPE\033[22m (one of: [d,dir,f,file])"
                echo "        File type."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --type|-t)
                _type="@@##@@"
                __optionWithValue=type
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    type)
                        _type=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILENAME ]]; then
            _FILENAME=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_type ]]; then
        if [[ $_type == "@@##@@" ]]; then echo "$__fn: Error: Value TYPE for option --type must be specified."; return 64; fi
        declare -A __allowed=( [d]=1 [dir]=1 [f]=1 [file]=1 )
        if [[ ! ${__allowed[$_type]} ]]; then echo "$__fn: Error: Value '$_type' for option --type is not one of the allowed values [d,dir,f,file]."; return 64; fi
    fi

    if [[ $_FILENAME ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILENAME must be specified."; return 64
    fi

    ######### find-up ######### START

local path=$PWD
while [[ $path ]]; do
    case $_type in
        d|dir)  if [[ -d "$path/$_FILENAME" ]]; then echo "$path/$_FILENAME"; return; fi ;;                            
        f|file) if [[ -f "$path/$_FILENAME" ]]; then echo "$path/$_FILENAME"; return; fi ;;
        *)      if [[ -e "$path/$_FILENAME" ]]; then echo "$path/$_FILENAME"; return; fi ;;                    
    esac
    path=${path%/*}
done
echo "$__fn: '$_FILENAME': No such file or directory"
return 1

    ######### find-up ######### END
}
function __complete-find-up() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --type -t --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        local prev="${COMP_WORDS[COMP_CWORD-1]}"
        case $prev in
            --type|-t)
                COMPREPLY=($(compgen -o default -W "d
dir
f
file" -- $curr))
              ;;
            *)
                COMPREPLY=($(compgen -o default -- $curr))
              ;;
        esac
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}find-up -- ${BASH_FUNK_PREFIX:--}find-up

function -findfiles() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [START_PATH] SEARCH_STRING"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-findfiles() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _lines _unpack _maxdepth _mindepth _name _help _selftest _verbose _START_PATH _SEARCH_STRING
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [START_PATH] SEARCH_STRING"
                echo
                echo "Recursively finds all files containing the given string and displays their path."
                echo
                echo "Parameters:"
                echo -e "  \033[1mSTART_PATH\033[22m (default: '.')"
                echo "      The path where to search."
                echo -e "  \033[1mSEARCH_STRING\033[22m (required)"
                echo "      The string to search."
                echo
                echo "Options:"
                echo -e "\033[1m-l, --lines\033[22m "
                echo "        Show matching lines of the files that contain the given string."
                echo -e "\033[1m    --maxdepth levels\033[22m (integer: ?-?)"
                echo "        The maximum number of levels to descend into the directory tree below the starting-point."
                echo -e "\033[1m    --mindepth levels\033[22m (integer: ?-?)"
                echo "        The level of directory tree below the starting-point where to start the search."
                echo -e "\033[1m    --name pattern\033[22m "
                echo "        Name pattern."
                echo -e "\033[1m-u, --unpack\033[22m "
                echo "        Unpack supported archives (.zip, .jar, .war, .ear)."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --lines|-l)
                _lines=1
            ;;

            --unpack|-u)
                _unpack=1
            ;;

            --maxdepth)
                _maxdepth="@@##@@"
                __optionWithValue=maxdepth
            ;;

            --mindepth)
                _mindepth="@@##@@"
                __optionWithValue=mindepth
            ;;

            --name)
                _name="@@##@@"
                __optionWithValue=name
            ;;

            --verbose|-v)
                _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    maxdepth)
                        _maxdepth=$__arg
                        __optionWithValue=
                      ;;
                    mindepth)
                        _mindepth=$__arg
                        __optionWithValue=
                      ;;
                    name)
                        _name=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_START_PATH && ${#__params[@]} > 1 ]]; then
            _START_PATH=$__param
            continue
        fi
        if [[ ! $_SEARCH_STRING ]]; then
            _SEARCH_STRING=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_START_PATH ]]; then _START_PATH="."; fi
    if [[ $_maxdepth ]]; then
        if [[ $_maxdepth == "@@##@@" ]]; then echo "$__fn: Error: Value levels for option --maxdepth must be specified."; return 64; fi
        if [[ ! "$_maxdepth" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_maxdepth' for option --maxdepth is not a numeric value."; return 64; fi
    fi
    if [[ $_mindepth ]]; then
        if [[ $_mindepth == "@@##@@" ]]; then echo "$__fn: Error: Value levels for option --mindepth must be specified."; return 64; fi
        if [[ ! "$_mindepth" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_mindepth' for option --mindepth is not a numeric value."; return 64; fi
    fi
    if [[ $_name ]]; then
        if [[ $_name == "@@##@@" ]]; then echo "$__fn: Error: Value pattern for option --name must be specified."; return 64; fi
    fi

    if [[ $_SEARCH_STRING ]]; then
        true
    else
        echo "$__fn: Error: Parameter SEARCH_STRING must be specified."; return 64
    fi

    ######### findfiles ######### START

if [[ ! -e "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] does not exist."
    return 1
fi

if [[ ! -r "$_START_PATH" ]]; then
    echo "Error: Path [$_START_PATH] is not readable by user '$USER'."
    return 1
fi

if [[ $_lines ]]; then
    local grepCmd="grep -n"
else
    local grepCmd="grep -l"
fi

local findOpts="-type f"
if [[ $_name ]]; then
    findOpts="$findOpts -name $_name"
fi
if [[ $_maxdepth ]]; then
    findOpts="$findOpts -maxdepth $_maxdepth"
fi
if [[ $_mindepth ]]; then
    findOpts="$findOpts -mindepth $_mindepth"
fi

# turn off verbose if part of pipe or subshell
[[ ! $__interactive ]] && _verbose= || true

if [[ $_verbose ]]; then
    if hash tput &>/dev/null; then
        cols=$(tput cols)
    else
        cols=$(stty size| cut -d' ' -f 2)
    fi

    find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
        local message="Scanning $file ..."

        echo -en "\033[s${message:0:$cols}"
        if [[ $_unpack && ( $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ) ]]; then
            if unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        else
            if LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>&1 >/dev/null; then
                echo -e "\033[u\033[K$file" || echo -e "$file"
            else
                echo -en "\033[u\033[K"
            fi
        fi
    done

else

    if [[ $_unpack ]]; then

        find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
            if [[ $file == *.zip || $file == *.jar || $file == *.ear || $file == *.war ]]; then
                unzip -p "$file" | LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null || true
            else
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            fi
        done

    else

        # to avoid "xargs: environment is too large for exec" on cygwin
        local xargsWorks=1
        if [[ $OSTYPE == cygwin ]]; then
            if ! echo whoami | xargs &>/dev/null; then
                local xargsWorks=
            fi
        fi

        if [[ $xargsWorks ]]; then
            find "$_START_PATH" $findOpts -print0 | LC_ALL=C xargs -r -0 -P2 $grepCmd "$_SEARCH_STRING" 2>/dev/null
        else
            find "$_START_PATH" $findOpts 2>/dev/null | while read file; do
                LC_ALL=C $grepCmd "$_SEARCH_STRING" "$file" 2>/dev/null
            done
        fi
    fi
fi

    ######### findfiles ######### END
}
function __complete-findfiles() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --lines -l --unpack -u --maxdepth --mindepth --name --help --selftest --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}findfiles -- ${BASH_FUNK_PREFIX:--}findfiles

function -ll() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-ll() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _PATH=()
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]..."
                echo
                echo "Alternative version of 'ls -lt' that prints directories (and sym-links to directories) before files and hidden entries before non-hidden entries."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m "
                echo "      The path to list."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ${#_PATH[@]} -lt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        local __leftoverParams=$(( ${#__params[@]} - 0 - ${#_PATH[@]} ))
        if [[ $__leftoverParams -gt 0 ]]; then
            _PATH+=("$__param")
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### ll ######### START

[[ ! $_PATH ]] && _PATH=(.) || true
local _lsopts
[[ ${OSTYPE} =~ "darwin" ]] && _lsopts=" -G" || _lsopts=" -I lost+found --color=always"
command ls -lAph${_lsopts} "${_PATH[@]}" | awk '
    BEGIN { dotDirs = ""; dirs = ""; dotFiles = ""; files = "" }
    /^total/                                                           { total = $0 }                   # capture total line

    /^d[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m)?[.].+/                { dotDirs = dotDirs "\n" $0 };   # capture hidden directories
    /^d[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m[^.]|[^\033^.])/        { dirs = dirs "\n" $0 };         # capture normal directories
    /^l[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m)?[.].+[\/]/            { dotDirs = dotDirs "\n" $0 };   # capture hidden sym-links to directories
    /^l[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m[^.]|[^\033^.]).*[\/]/  { dirs = dirs "\n" $0 };         # capture normal sym-links to directories

    /^-[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m)?[.].+/                { dotFiles = dotFiles "\n" $0 }; # capture hidden files
    /^-[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m[^.]|[^\033^.])/        { files = files "\n" $0 };       # capture normal files
    /^l[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m)?[.].+[^\/]/           { dotFiles = dotFiles "\n" $0 }; # capture hidden sym-links to files
    /^l[rwx+-]+ .*[0-9]+:[0-9]+ (\033\[[0-9;]+m[^.]|[^\033^.]).*[^\/]/ { files = files "\n" $0 };       # capture normal sym-links to files
    END { print total dotDirs dirs dotFiles files }'

    ######### ll ######### END
}
function __complete-ll() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}ll -- ${BASH_FUNK_PREFIX:--}ll

function -mkcd() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... PATH"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-mkcd() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _mode _parents _help _selftest _verbose _PATH
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... PATH"
                echo
                echo "Creates a directory and changes into it."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (required)"
                echo "      The path to create."
                echo
                echo "Options:"
                echo -e "\033[1m-m, --mode MODE\033[22m (pattern: \"[0-7]{3}\")"
                echo "        The file mode for the new directory."
                echo -e "\033[1m-p, --parents\033[22m "
                echo "        Automatically create missing parent directories."
                echo -e "\033[1m-v, --verbose\033[22m "
                echo "        Prints additional information during command execution."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --mode|-m)
                _mode="@@##@@"
                __optionWithValue=mode
            ;;

            --parents|-p)
                _parents=1
            ;;

            --verbose|-v)
                _verbose=1
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    mode)
                        _mode=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_mode ]]; then
        if [[ $_mode == "@@##@@" ]]; then echo "$__fn: Error: Value MODE for option --mode must be specified."; return 64; fi
        if [[ ! "$_mode" =~ ^[0-7]{3}$ ]]; then echo "$__fn: Error: Value '$_mode' for option --mode does not match required pattern '[0-7]{3}'."; return 64; fi
    fi

    if [[ $_PATH ]]; then
        true
    else
        echo "$__fn: Error: Parameter PATH must be specified."; return 64
    fi

    ######### mkcd ######### START

local mkdirOpts

[[ $_mode    ]] && mkdirOpts="$mkdirOpts -m $_mode" || true
[[ $_parents ]] && mkdirOpts="$mkdirOpts -p" || true
[[ $_verbose ]] && mkdirOpts="$mkdirOpts -v" || true

mkdir "$_PATH" && cd "$_PATH"

    ######### mkcd ######### END
}
function __complete-mkcd() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --mode -m --parents -p --help --selftest --verbose -v "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}mkcd -- ${BASH_FUNK_PREFIX:--}mkcd

function -modified() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-modified() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _format _help _selftest _PATH
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the modification timestamp of the given file or directory."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.', path)"
                echo "      The file or directory to check."
                echo
                echo "Options:"
                echo -e "\033[1m-f, --format FORMAT\033[22m (one of: [locale,iso8601,human])"
                echo "        Prints the timestamp in the given format."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --format|-f)
                _format="@@##@@"
                __optionWithValue=format
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    format)
                        _format=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi
    if [[ $_format ]]; then
        if [[ $_format == "@@##@@" ]]; then echo "$__fn: Error: Value FORMAT for option --format must be specified."; return 64; fi
        declare -A __allowed=( [locale]=1 [iso8601]=1 [human]=1 )
        if [[ ! ${__allowed[$_format]} ]]; then echo "$__fn: Error: Value '$_format' for option --format is not one of the allowed values [locale,iso8601,human]."; return 64; fi
    fi

    if [[ $_PATH ]]; then
        if [[ ! -e "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH does not exist."; return 64; fi
    true
        if [[ ! -r "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH is not readable by user '$USER'."; return 64; fi
    fi

    ######### modified ######### START


case $_format in
    human)
        find "$_PATH" -maxdepth 0 -printf "%TY.%Tm.%Td %TT %TZ\n"
        return
      ;;
    locale)
        find "$_PATH" -maxdepth 0 -printf "%Tc\n"
        return
      ;;
esac

local timestamp=$(
# use stat if available
if hash stat &>/dev/null; then
    echo $(stat -c %Y "$_PATH")

# use perl if available
elif hash perl &>/dev/null; then
    perl << EOF
use File::stat;
print stat("$_PATH")->mtime, "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print int(os.path.getmtime('$_PATH'))"
fi
)

if [[ $_format == "iso8601" ]]; then
    date --iso-8601=seconds -d@$timestamp
    return
fi

echo $timestamp

    ######### modified ######### END
}
function __complete-modified() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --format -f --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        local prev="${COMP_WORDS[COMP_CWORD-1]}"
        case $prev in
            --format|-f)
                COMPREPLY=($(compgen -o default -W "locale
iso8601
human" -- $curr))
              ;;
            *)
                COMPREPLY=($(compgen -o default -- $curr))
              ;;
        esac
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}modified -- ${BASH_FUNK_PREFIX:--}modified

function -owner() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-owner() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _PATH
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the owner of the given file or directory."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.', path)"
                echo "      The file or directory to check."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    if [[ $_PATH ]]; then
        if [[ ! -e "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH does not exist."; return 64; fi
    true
        if [[ ! -r "$_PATH" ]]; then echo "$__fn: Error: Path '$_PATH' for parameter PATH is not readable by user '$USER'."; return 64; fi
    fi

    ######### owner ######### START

# use stat if available
if hash stat &>/dev/null; then
    echo $(stat -c %U "$_PATH")

# use perl if available
elif hash perl &>/dev/null; then
    perl << EOF
use File::stat;
print getpwuid(stat("$_PATH")->uid), "\n"
EOF

# use python as last resort
else
    python -c "import os, pwd
print pwd.getpwuid(os.stat('$_PATH').st_uid).pw_name"
fi

    ######### owner ######### END
}
function __complete-owner() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}owner -- ${BASH_FUNK_PREFIX:--}owner

function -realpath() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... [PATH]"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-realpath() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _PATH
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... [PATH]"
                echo
                echo "Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
                echo
                echo "Parameters:"
                echo -e "  \033[1mPATH\033[22m (default: '.', path)"
                echo "      The path to normalize."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_PATH && ${#__params[@]} > 0 ]]; then
            _PATH=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ ! $_PATH ]]; then _PATH="."; fi

    if [[ $_PATH ]]; then
    true
    fi

    ######### realpath ######### START

# use readlink if available
if hash readlink &>/dev/null; then
    readlink -m "$_PATH"

# use perl if available
elif hash perl &>/dev/null; then
    perl << EOF
use Cwd 'abs_path';
print abs_path('$_PATH'), "\n"
EOF

# use python as last resort
else
    python -c "import os
print os.path.realpath('$_PATH')"
fi

    ######### realpath ######### END
}
function __complete-realpath() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}realpath -- ${BASH_FUNK_PREFIX:--}realpath

function -sudo-append() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE_PATH CONTENT"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-sudo-append() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _FILE_PATH _CONTENT
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... FILE_PATH CONTENT"
                echo
                echo "Creates a file with the given content."
                echo
                echo "Requirements:"
                echo "  + Sudo 'tee --append' is required."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE_PATH\033[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \033[1mCONTENT\033[22m (required)"
                echo "      The content to append to the file."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg 'foo=bar'\033[22m"
                echo -e "Appending to \[/tmp/testfile.cfg\]..."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg 'foo=bar'\033[22m"
                __stdout="$($__fn /tmp/testfile.cfg 'foo=bar')"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Appending to \[/tmp/testfile.cfg\]...$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Appending to \[/tmp/testfile.cfg\]...]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$__param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILE_PATH must be specified."; return 64
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "$__fn: Error: Parameter CONTENT must be specified."; return 64
    fi

    if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
    if ! sudo -l -- tee --append &>/dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'tee --append'"; return 64; fi

    ######### sudo-append ######### START

echo "Appending to [$_FILE_PATH]..."
echo "$_CONTENT" | sudo tee --append "$_FILE_PATH" > /dev/null

    ######### sudo-append ######### END
}
function __complete-sudo-append() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sudo-append -- ${BASH_FUNK_PREFIX:--}sudo-append

function -sudo-write() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE_PATH OWNER CONTENT"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-sudo-write() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest _FILE_PATH _OWNER _CONTENT
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... FILE_PATH OWNER CONTENT"
                echo
                echo "Creates a file with the given content."
                echo
                echo "Requirements:"
                echo "  + Sudo 'sh -c' is required."
                echo "  + Sudo 'sh chown' is required."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE_PATH\033[22m (required)"
                echo "      The path to the file to write."
                echo -e "  \033[1mOWNER\033[22m (required)"
                echo "      The owner and group to set."
                echo -e "  \033[1mCONTENT\033[22m (required)"
                echo "      The content to write."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                echo "Examples:"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg $USER:$USER 'foo=bar'\033[22m"
                echo -e "Writing \[/tmp/testfile.cfg\]..."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo -e "$ \033[1m$__fn /tmp/testfile.cfg $USER:$USER 'foo=bar'\033[22m"
                __stdout="$($__fn /tmp/testfile.cfg $USER:$USER 'foo=bar')"; __rc=$?
                echo "$__stdout"
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                __regex="^Writing \[/tmp/testfile.cfg\]...$"
                if [[ ! "$__stdout" =~ $__regex ]]; then echo -e "--> \033[31mFAILED\033[0m - stdout [$__stdout] does not match required pattern [Writing \[/tmp/testfile.cfg\]...]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE_PATH ]]; then
            _FILE_PATH=$__param
            continue
        fi
        if [[ ! $_OWNER ]]; then
            _OWNER=$__param
            continue
        fi
        if [[ ! $_CONTENT ]]; then
            _CONTENT=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_FILE_PATH ]]; then
        true
    else
        echo "$__fn: Error: Parameter FILE_PATH must be specified."; return 64
    fi
    if [[ $_OWNER ]]; then
        true
    else
        echo "$__fn: Error: Parameter OWNER must be specified."; return 64
    fi
    if [[ $_CONTENT ]]; then
        true
    else
        echo "$__fn: Error: Parameter CONTENT must be specified."; return 64
    fi

    if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
    if ! sudo -l -- sh -c &>/dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'sh -c'"; return 64; fi
    if ! hash "sudo" &>/dev/null; then echo "$__fn: Error: Required command 'sudo' not found on this system."; return 64; fi
    if ! sudo -l -- sh chown &>/dev/null; then echo "$__fn: Error: User $USER misses required sudo permission for 'sh chown'"; return 64; fi

    ######### sudo-write ######### START

echo "Writing [$_FILE_PATH]..."
sudo sh -c "echo '$_CONTENT' > '$_FILE_PATH'" && sudo chown "$_OWNER" "$_FILE_PATH"

    ######### sudo-write ######### END
}
function __complete-sudo-write() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}sudo-write -- ${BASH_FUNK_PREFIX:--}sudo-write

function -tail-reverse() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]... FILE"
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-tail-reverse() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _unique _lines _help _selftest _FILE
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]... FILE"
                echo
                echo "Prints the last N lines of the given text file in reverse order."
                echo
                echo "Parameters:"
                echo -e "  \033[1mFILE\033[22m (required, file)"
                echo "      Path to the file."
                echo
                echo "Options:"
                echo -e "\033[1m-n, --lines N\033[22m (integer: ?-?)"
                echo "        The maximum number of lines to output."
                echo -e "\033[1m-u, --unique\033[22m "
                echo "        Don't print duplicates."
                echo "    -----------------------------"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            --unique|-u)
                _unique=1
            ;;

            --lines|-n)
                _lines="@@##@@"
                __optionWithValue=lines
            ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    lines)
                        _lines=$__arg
                        __optionWithValue=
                      ;;
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        if [[ ! $_FILE ]]; then
            _FILE=$__param
            continue
        fi
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    if [[ $_lines ]]; then
        if [[ $_lines == "@@##@@" ]]; then echo "$__fn: Error: Value N for option --lines must be specified."; return 64; fi
        if [[ ! "$_lines" =~ ^-?[0-9]*$ ]]; then echo "$__fn: Error: Value '$_lines' for option --lines is not a numeric value."; return 64; fi
    fi

    if [[ $_FILE ]]; then
        if [[ ! -e "$_FILE" ]]; then echo "$__fn: Error: File '$_FILE' for parameter FILE does not exist."; return 64; fi
        if [[ -e "$_FILE" && ! -f "$_FILE" ]]; then echo "$__fn: Error: Path '$_FILE' for parameter FILE is not a file."; return 64; fi
        if [[ ! -r "$_FILE" ]]; then echo "$__fn: Error: File '$_FILE' for parameter FILE is not readable by user '$USER'."; return 64; fi
    else
        echo "$__fn: Error: Parameter FILE must be specified."; return 64
    fi

    ######### tail-reverse ######### START

if [[ $_unique ]]; then
    if [[ $_lines ]]; then
        awk "{lines[len++]=\$0} END {for(i=len-1;i>=0;i--) if (occurrences[lines[i]]++ == 0) { print lines[i]; count++; if (count>=$_lines) break}}" $_FILE
    else
        awk "{lines[len++]=\$0} END {for(i=len-1;i>=0;i--) if (occurrences[lines[i]]++ == 0) print lines[i]}" $_FILE
    fi
else
    if [[ $_lines ]]; then
        awk "{lines[len++]=\$0} END {for(i=len-1;len-i<=$_lines;i--) print lines[i]}" $_FILE
    else
        awk "{lines[len++]=\$0} END {for(i=len-1;i>=0;i--) print lines[i]}" $_FILE
    fi
fi

    ######### tail-reverse ######### END
}
function __complete-tail-reverse() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --unique -u --lines -n --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}tail-reverse -- ${BASH_FUNK_PREFIX:--}tail-reverse

function -test-filesystem() {
    local opts="" opt rc __fn=${FUNCNAME[0]}
    for opt in a u H t; do
        [[ $- =~ $opt ]] && opts="set -$opt; $opts" || opts="set +$opt; $opts"
    done
    shopt -q -o pipefail && opts="set -o pipefail; $opts" || opts="set +o pipefail; $opts"
    for opt in nullglob extglob nocasematch nocaseglob; do
        shopt -q $opt && opts="shopt -s $opt; $opts" || opts="shopt -u $opt; $opts"
    done

    set +auHt
    set -o pipefail

    __impl$__fn "$@" && rc=0 || rc=$?

    if [[ $rc == 64 && -t 1 ]]; then
        echo; echo "Usage: $__fn [OPTION]..."
        echo; echo "Type '$__fn --help' for more details."
    fi

    eval $opts

    return $rc
}
function __impl-test-filesystem() {
    local __args=() __arg __idx __optionWithValue __params=() __interactive __fn=${FUNCNAME[0]/__impl/} _help _selftest
    [ -t 1 ] && __interactive=1 || true
    
    for __arg in "$@"; do
        case "$__arg" in
            -|--*) __args+=("$__arg") ;;
            -*) for ((__idx=1; __idx<${#__arg}; __idx++)); do __args+=("-${__arg:$__idx:1}"); done ;;
            *) __args+=("$__arg") ;;
        esac
    done
    for __arg in "${__args[@]}"; do
        case "$__arg" in

            --help)
                echo "Usage: $__fn [OPTION]..."
                echo
                echo "Performs a selftest of all functions of this module by executing each function with option '--selftest'."
                echo
                echo "Options:"
                echo -e "\033[1m    --help\033[22m "
                echo "        Prints this help."
                echo -e "\033[1m    --selftest\033[22m "
                echo "        Performs a self-test."
                echo
                return 0
              ;;

            --selftest)
                echo "Testing function [$__fn]..."
                echo -e "$ \033[1m$__fn --help\033[22m"
                local __stdout __rc
                __stdout="$($__fn --help)"; __rc=$?
                if [[ $__rc != 0 ]]; then echo -e "--> \033[31mFAILED\033[0m - exit code [$__rc] instead of expected [0]."; return 64; fi
                echo -e "--> \033[32mOK\033[0m"
                echo "Testing function [$__fn]...DONE"
                return 0
              ;;

            -*)
                echo "$__fn: invalid option: '$__arg'"
                return 64
              ;;

            *)
                case $__optionWithValue in
                    *)
                        __params+=("$__arg")
                esac
              ;;
        esac
    done

    for __param in "${__params[@]}"; do
        echo "$__fn: Error: too many parameters: '$__param'"
        return 64
    done

    ######### test-filesystem ######### START

${BASH_FUNK_PREFIX:--}abspath --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cd-down --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cd-hist --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}cd-up --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}count-words --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}du --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}extract --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}find-up --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}findfiles --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}ll --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}mkcd --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}modified --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}owner --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}realpath --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sudo-append --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}sudo-write --selftest && echo || return 1
${BASH_FUNK_PREFIX:--}tail-reverse --selftest && echo || return 1

    ######### test-filesystem ######### END
}
function __complete-test-filesystem() {
    local curr=${COMP_WORDS[COMP_CWORD]}
    if [[ ${curr} == -* ]]; then
        local options=" --help --selftest "
        for o in "${COMP_WORDS[@]}"; do options=${options/ $o / }; done
        COMPREPLY=($(compgen -o default -W '$options' -- $curr))
    else
        COMPREPLY=($(compgen -o default -- $curr))
    fi
}
complete -F __complete${BASH_FUNK_PREFIX:--}test-filesystem -- ${BASH_FUNK_PREFIX:--}test-filesystem


function -help-filesystem() {
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}abspath [PATH]\033[0m  -  Prints the normalized path of the given path WITHOUT resolving symbolic links. The path is not required to exist."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}cd-down DIR_NAME\033[0m  -  Jumps down in the tree of the current directory to the first sub directory found with the given name."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}cd-hist [STEPS_OR_DIRNAME]\033[0m  -  Navigates back in the directory history which can be managed via pushd/popd/dirs and is automatically populated if the Bash Funk bash-prompt is installed."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}cd-up [LEVEL_OR_PATTERN]\033[0m  -  Navigates up in the current directory tree to the first parent directory found with the given namen or the given number of levels. Bash completion will auto-complete the names of the parent directories."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}count-words FILE WORD1[WORD]...\033[0m  -  Counts the number of occurences of the word(s) in the given file."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}du [PATH]...\033[0m  -  Prints disk usage information."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}extract ARCHIVE [TO_DIR]\033[0m  -  Extracts the given archive using the compatible extractor."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}find-up FILENAME\033[0m  -  Traverses the directory upward to find the given file."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}findfiles [START_PATH] SEARCH_STRING\033[0m  -  Recursively finds all files containing the given string and displays their path."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}ll [PATH]...\033[0m  -  Alternative version of 'ls -lt' that prints directories (and sym-links to directories) before files and hidden entries before non-hidden entries."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}mkcd PATH\033[0m  -  Creates a directory and changes into it."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}modified [PATH]\033[0m  -  Prints the modification timestamp of the given file or directory."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}owner [PATH]\033[0m  -  Prints the owner of the given file or directory."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}realpath [PATH]\033[0m  -  Prints the normalized path of the given path resolving any symbolic links. The path is not required to exist."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}sudo-append FILE_PATH CONTENT\033[0m  -  Creates a file with the given content."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}sudo-write FILE_PATH OWNER CONTENT\033[0m  -  Creates a file with the given content."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}tail-reverse FILE\033[0m  -  Prints the last N lines of the given text file in reverse order."
    echo -e "\033[1m${BASH_FUNK_PREFIX:--}test-filesystem\033[0m  -  Performs a selftest of all functions of this module by executing each function with option '--selftest'."

}
__BASH_FUNK_FUNCS+=( abspath cd-down cd-hist cd-up count-words du extract find-up findfiles ll mkcd modified owner realpath sudo-append sudo-write tail-reverse test-filesystem )
